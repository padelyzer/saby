#!/usr/bin/env python3
"""
Bot de Trading Avanzado con Pools de Liquidez
Combina an√°lisis de estructura de mercado y liquidez
"""

import time
import json
import yfinance as yf
import pandas as pd
from datetime import datetime, timedelta
import os
import sys

# Importar m√≥dulos del sistema
from advanced_signals import AdvancedSignalDetector, format_advanced_signal
from liquidity_pools import LiquidityPoolDetector, format_liquidity_report
from signal_manager import SignalManager, TradingSignal
from motor_trading import calcular_semaforo_mercado

class AdvancedTradingBot:
    """Bot avanzado con an√°lisis de liquidez"""
    
    def __init__(self, config_file='signal_config.json'):
        self.config_file = config_file
        self.signal_detector = AdvancedSignalDetector()
        self.liquidity_detector = LiquidityPoolDetector()
        self.signal_manager = SignalManager(config_file)
        self.last_signals = {}  # Para evitar duplicados
        self.stats = {
            'signals_sent': 0,
            'liquidity_alerts': 0,
            'start_time': datetime.now()
        }
        
        # Lista de criptomonedas a monitorear
        self.watchlist = [
            'BTC-USD', 'ETH-USD', 'BNB-USD', 'SOL-USD', 'XRP-USD',
            'ADA-USD', 'AVAX-USD', 'DOT-USD', 'MATIC-USD', 'LINK-USD',
            'UNI-USD', 'ATOM-USD', 'FIL-USD', 'NEAR-USD', 'APT-USD'
        ]
    
    def check_signal_cooldown(self, ticker: str, minutes: int = 60) -> bool:
        """Verifica si ha pasado suficiente tiempo desde la √∫ltima se√±al"""
        if ticker not in self.last_signals:
            return True
        
        last_time = self.last_signals[ticker]
        if datetime.now() - last_time > timedelta(minutes=minutes):
            return True
        
        return False
    
    def analyze_ticker(self, ticker: str) -> dict:
        """Analiza un ticker con todos los sistemas"""
        results = {
            'ticker': ticker,
            'timestamp': datetime.now().isoformat(),
            'signal': None,
            'liquidity': None,
            'risk_analysis': None
        }
        
        try:
            # Obtener datos
            stock = yf.Ticker(ticker)
            df = stock.history(period='3mo', interval='1h')
            
            if len(df) < 200:
                return results
            
            current_price = float(df['Close'].iloc[-1])
            
            # 1. Buscar se√±al avanzada
            signal = self.signal_detector.generate_advanced_signal(ticker, df)
            
            if signal:
                results['signal'] = signal
                
                # 2. An√°lisis de liquidez
                liquidity_data = self.liquidity_detector.detect_liquidity_pools(df, current_price)
                results['liquidity'] = liquidity_data
                
                # 3. An√°lisis de riesgo basado en liquidez
                risk_analysis = self.liquidity_detector.analyze_liquidity_risk(
                    df, 
                    signal['entry_price'],
                    signal['stop_loss'],
                    signal['primary_target']['price'],
                    signal['type']
                )
                results['risk_analysis'] = risk_analysis
        
        except Exception as e:
            print(f"Error analizando {ticker}: {e}")
        
        return results
    
    def format_telegram_signal(self, analysis: dict) -> str:
        """Formatea se√±al completa para Telegram"""
        signal = analysis['signal']
        risk = analysis.get('risk_analysis', {})
        
        emoji = "üü¢" if signal['type'] == 'LONG' else "üî¥"
        
        message = f"""
{emoji} **SE√ëAL AVANZADA {signal['type']}** {emoji}
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
üìä **{signal['ticker']}**
üíØ **Score:** {signal['score']}/10
üìç **Estructura:** {signal['market_structure']}

**NIVELES DE TRADING:**
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üí∞ **Entrada:** ${signal['entry_price']:.4f}
üõë **Stop Loss:** ${signal['stop_loss']:.4f}
üéØ **Target 1:** ${signal['primary_target']['price']:.4f}
   _{signal['primary_target']['reason']}_
üöÄ **Target 2:** ${signal['extended_target']['price']:.4f}
   _{signal['extended_target']['reason']}_

**RATIOS:**
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üìä **R:R Target 1:** {signal['risk_reward_ratio']}:1
üìà **R:R Target 2:** {signal['extended_rr_ratio']}:1

**CONFLUENCIAS ({signal['confluence_points']}):**
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
"""
        
        for reason in signal['entry_reasons'][:5]:  # Max 5 razones
            message += f"‚Ä¢ {reason}\n"
        
        # Agregar an√°lisis de riesgo de liquidez
        if risk:
            message += f"""
üíß **AN√ÅLISIS DE LIQUIDEZ:**
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
Risk Score: {risk.get('risk_score', 0)}/10
Clasificaci√≥n: {risk.get('classification', 'N/A')}
"""
            
            if risk.get('warnings'):
                message += "\n‚ö†Ô∏è **Advertencias:**\n"
                for warning in risk['warnings'][:2]:
                    message += f"‚Ä¢ {warning}\n"
            
            if risk.get('adjustments'):
                message += "\nüîß **Ajustes Sugeridos:**\n"
                for adj in risk['adjustments'][:2]:
                    message += f"‚Ä¢ {adj}\n"
        
        # Agregar pools de liquidez cercanos
        if 'liquidity_pools' in signal['chart_analysis']:
            top_pools = signal['chart_analysis']['liquidity_pools'][:3]
            if top_pools:
                message += "\nüíß **Pools de Liquidez Cercanos:**\n"
                for pool in top_pools:
                    direction = "‚Üë" if pool['direction'] == 'ABOVE' else "‚Üì"
                    message += f"‚Ä¢ ${pool['price']:.2f} ({pool['distance_pct']:+.2f}%) {direction}\n"
        
        message += f"""
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚è∞ {datetime.now().strftime('%H:%M:%S')}
ü§ñ Bot Avanzado v2.0
"""
        
        return message
    
    def send_liquidity_alert(self, ticker: str, liquidity_data: dict):
        """Env√≠a alerta sobre pools de liquidez importantes"""
        # Solo alertar sobre pools muy fuertes
        strong_pools = [p for p in liquidity_data['heatmap'] if p['importance'] > 10]
        
        if not strong_pools:
            return
        
        message = f"""
üíß **ALERTA DE LIQUIDEZ - {ticker}** üíß
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Pools de liquidez importantes detectados:
"""
        
        for pool in strong_pools[:3]:
            direction = "‚Üë" if pool['direction'] == 'ABOVE' else "‚Üì"
            emoji = "üî¥" if 'SHORT' in pool['type'] else "üü¢"
            
            message += f"""
{emoji} ${pool['price']:.2f} ({pool['distance_pct']:+.2f}%) {direction}
   Fuerza: {'‚ñà' * int(pool['strength']/2)}
   Tipo: {pool['type']}
"""
        
        message += """
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚ö†Ô∏è Estos niveles pueden actuar como imanes de precio
"""
        
        # Enviar alerta
        try:
            for channel in self.signal_manager.channels:
                if hasattr(channel, 'send'):
                    # Crear se√±al especial para alerta
                    alert_signal = TradingSignal(
                        timestamp=datetime.now().isoformat(),
                        ticker=ticker,
                        action="ALERT",
                        price=liquidity_data['current_price'],
                        stop_loss=0,
                        take_profit=0,
                        score=0,
                        direccion="NEUTRAL",
                        timeframe="1H"
                    )
                    alert_signal.format_message = lambda: message
                    channel.send(alert_signal)
            
            self.stats['liquidity_alerts'] += 1
            
        except Exception as e:
            print(f"Error enviando alerta de liquidez: {e}")
    
    def scan_market(self):
        """Escanea el mercado buscando oportunidades"""
        print(f"\nüîç Escaneando {len(self.watchlist)} activos...")
        print(f"‚è∞ {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        
        # Verificar estado del mercado
        estado_mercado = calcular_semaforo_mercado()
        print(f"üìä Estado del mercado: {estado_mercado}")
        
        if estado_mercado == 'AMARILLO':
            print("‚ö†Ô∏è Mercado neutral - Modo conservador activado")
        
        signals_found = []
        liquidity_alerts = []
        
        for ticker in self.watchlist:
            try:
                # Verificar cooldown
                if not self.check_signal_cooldown(ticker, minutes=60):
                    continue
                
                print(f"  Analizando {ticker}...", end="")
                
                # An√°lisis completo
                analysis = self.analyze_ticker(ticker)
                
                if analysis['signal']:
                    signal = analysis['signal']
                    
                    # Filtro adicional basado en riesgo
                    risk = analysis.get('risk_analysis', {})
                    if risk.get('risk_score', 10) > 7:
                        print(f" ‚ö†Ô∏è Riesgo alto ({risk['risk_score']}/10)")
                        continue
                    
                    print(f" ‚úÖ Se√±al {signal['type']} (Score: {signal['score']})")
                    signals_found.append(analysis)
                    
                    # Actualizar √∫ltimo tiempo de se√±al
                    self.last_signals[ticker] = datetime.now()
                    
                elif analysis['liquidity']:
                    # Verificar si hay pools importantes aunque no haya se√±al
                    liquidity = analysis['liquidity']
                    strong_pools = [p for p in liquidity['heatmap'] if p['importance'] > 15]
                    
                    if strong_pools:
                        print(f" üíß Pools de liquidez detectados")
                        liquidity_alerts.append((ticker, liquidity))
                    else:
                        print(" ‚úì")
                else:
                    print(" ‚úì")
                
            except Exception as e:
                print(f" ‚ùå Error: {e}")
                continue
        
        return signals_found, liquidity_alerts
    
    def run(self, interval_minutes: int = 5):
        """Ejecuta el bot continuamente"""
        print("""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë           ü§ñ BOT DE TRADING AVANZADO CON LIQUIDEZ               ‚ïë
‚ïë                    Versi√≥n 2.0 - Producci√≥n                     ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
        """)
        
        print(f"üìä Monitoreando: {len(self.watchlist)} activos")
        print(f"‚è∞ Intervalo: {interval_minutes} minutos")
        print(f"üîî Canales activos: {len(self.signal_manager.channels)}")
        print("\nPresiona Ctrl+C para detener\n")
        
        while True:
            try:
                # Escanear mercado
                signals, liquidity_alerts = self.scan_market()
                
                # Enviar se√±ales
                if signals:
                    print(f"\nüì§ Enviando {len(signals)} se√±ales...")
                    
                    for analysis in signals:
                        signal = analysis['signal']
                        
                        # Crear objeto TradingSignal
                        trading_signal = TradingSignal(
                            timestamp=datetime.now().isoformat(),
                            ticker=signal['ticker'],
                            action=f"BUY_{signal['type']}",
                            price=signal['entry_price'],
                            stop_loss=signal['stop_loss'],
                            take_profit=signal['primary_target']['price'],
                            score=signal['score'],
                            direccion=signal['type'],
                            timeframe="1H",
                            leverage=3,
                            position_size_pct=5.0,
                            risk_reward_ratio=signal['risk_reward_ratio'],
                            confidence="HIGH" if signal['score'] >= 8 else "MEDIUM"
                        )
                        
                        # Sobrescribir m√©todo format_message con nuestro formato
                        original_format = trading_signal.format_message
                        trading_signal.format_message = lambda a=analysis: self.format_telegram_signal(a)
                        
                        # Enviar se√±al
                        results = self.signal_manager.broadcast_signal(trading_signal)
                        
                        # Restaurar m√©todo original
                        trading_signal.format_message = original_format
                        
                        self.stats['signals_sent'] += 1
                        
                        print(f"  ‚úÖ {signal['ticker']} - {signal['type']} enviado")
                
                # Enviar alertas de liquidez importantes
                if liquidity_alerts:
                    print(f"\nüíß Enviando {len(liquidity_alerts)} alertas de liquidez...")
                    
                    for ticker, liquidity_data in liquidity_alerts:
                        self.send_liquidity_alert(ticker, liquidity_data)
                        print(f"  ‚úÖ Alerta de liquidez para {ticker}")
                
                # Mostrar estad√≠sticas
                self.print_stats()
                
                # Esperar hasta el pr√≥ximo escaneo
                print(f"\n‚è≥ Pr√≥ximo escaneo en {interval_minutes} minutos...")
                print("=" * 60)
                time.sleep(interval_minutes * 60)
                
            except KeyboardInterrupt:
                print("\n\nüõë Bot detenido por el usuario")
                self.print_final_stats()
                break
            except Exception as e:
                print(f"\n‚ùå Error en el bot: {e}")
                print("Reiniciando en 30 segundos...")
                time.sleep(30)
    
    def print_stats(self):
        """Muestra estad√≠sticas actuales"""
        runtime = datetime.now() - self.stats['start_time']
        hours = runtime.total_seconds() / 3600
        
        print(f"""
üìä ESTAD√çSTICAS:
‚Ä¢ Tiempo activo: {runtime}
‚Ä¢ Se√±ales enviadas: {self.stats['signals_sent']}
‚Ä¢ Alertas de liquidez: {self.stats['liquidity_alerts']}
‚Ä¢ Promedio: {self.stats['signals_sent']/max(hours, 1):.1f} se√±ales/hora
        """)
    
    def print_final_stats(self):
        """Muestra estad√≠sticas finales"""
        runtime = datetime.now() - self.stats['start_time']
        
        print(f"""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                     üìä RESUMEN DE SESI√ìN                        ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

Tiempo total: {runtime}
Se√±ales enviadas: {self.stats['signals_sent']}
Alertas de liquidez: {self.stats['liquidity_alerts']}

‚úÖ Bot finalizado correctamente
        """)

def main():
    """Funci√≥n principal"""
    # Verificar configuraci√≥n
    if not os.path.exists('signal_config.json'):
        print("‚ùå No se encontr√≥ signal_config.json")
        print("Ejecuta primero: python3 signal_manager.py")
        return
    
    # Crear y ejecutar bot
    bot = AdvancedTradingBot()
    
    # Par√°metros configurables
    interval = 5  # minutos entre escaneos
    
    if len(sys.argv) > 1:
        try:
            interval = int(sys.argv[1])
        except:
            print("Uso: python3 signal_bot_advanced.py [intervalo_minutos]")
            return
    
    # Ejecutar bot
    bot.run(interval_minutes=interval)

if __name__ == "__main__":
    main()